#' transform a bounding box
#'
#' Transforms an `sf` style bounding box object into the specified coordinate
#' reference system.
#'
#' @param bbox Object of class 'bbox' generated by
#'   \code{\link[sf:st_bbox]{sf::st_bbox}}.
#' @param crs EPSG code of desired coordinate reference system.
#' @return 'bbox' object with the desired CRS.
#' @note This is a stopgap until and unless a dedicated sf method for bbox
#' transformations is written. Currently used to coerce to WGS84 under specific
#' circumstances. Since this helper was written for an Australia-specific package,
#' it is assumed that it will be used to transform coordinates from a fairly
#' limited list of known crs's, chiefly GDA94 (EPSG:4283) and its associated
#' UTM and Albers equal area projections.
#' @keywords internal
#' @importFrom sf st_bbox st_crs st_point st_sfc st_transform
#'
transform_bb <- function(bbox = NULL, crs = 4283) {
  box <- sf::st_as_sfc(bbox, crs = sf::st_crs(bbox))
  new <- sf::st_transform(box, crs)
  sf::st_bbox(new)
}

#' align bounding box
#'
#' Cheerfully stolen from code{\link[raster:alignExtent]{raster::alignExtent}}
#' and adapted to sf bbox objects. This is designed to prevent WCS server-side
#' interpolation.
#'
#' @param aoi `sf` bbox object
#' @param product Character, one of the options from column 'Short_Name' in
#'   \code{\link[slga:slga_product_info]{slga_product_info}}.
#' @param snap Character; 'near', 'in', or 'out'. Defaults to 'out'.
#' @keywords internal
#' @importFrom utils data
#'
align_aoi <- function(aoi = NULL, product = NULL, snap = "out")
{
  snap <- match.arg(snap, c("near", "in", "out"))
  slga_product_info <- NULL
  utils::data('slga_product_info', envir = environment())

  res <- abs(
    c(slga_product_info$offset_x[which(slga_product_info$Short_Name == product)],
      slga_product_info$offset_y[which(slga_product_info$Short_Name == product)]))

  orig <-
    c(slga_product_info$origin_x[which(slga_product_info$Short_Name == product)],
      slga_product_info$origin_y[which(slga_product_info$Short_Name == product)])

   if (snap == "near") {
    xmn <- round((aoi['xmin'] - orig[1])/res[1]) * res[1] +
      orig[1]
    xmx <- round((aoi['xmax'] - orig[1])/res[1]) * res[1] +
      orig[1]
    ymn <- round((aoi['ymin'] - orig[2])/res[2]) * res[2] +
      orig[2]
    ymx <- round((aoi['ymax'] - orig[2])/res[2]) * res[2] +
      orig[2]
  }
  if (snap == "out") {
    xmn <- floor((aoi['xmin'] - orig[1])/res[1]) * res[1] +
      orig[1]
    xmx <- ceiling((aoi['xmax'] - orig[1])/res[1]) * res[1] +
      orig[1]
    ymn <- floor((aoi['ymin'] - orig[2])/res[2]) * res[2] +
      orig[2]
    ymx <- ceiling((aoi['ymax'] - orig[2])/res[2]) * res[2] +
      orig[2]
  }
  if (snap == "in") {
    xmn <- ceiling((aoi['xmin'] - orig[1])/res[1]) * res[1] +
      orig[1]
    xmx <- floor((aoi['xmax'] - orig[1])/res[1]) * res[1] +
      orig[1]
    ymn <- ceiling((aoi['ymin'] - orig[2])/res[2]) * res[2] +
      orig[2]
    ymx <- floor((aoi['ymax'] - orig[2])/res[2]) * res[2] +
      orig[2]
  }
  if (xmn == xmx) {
    if (xmn <= aoi['xmin']) {
      xmx <- xmx + res[1]
    }
    else {
      xmn <- xmn - res[1]
    }
  }
  if (ymn == ymx) {
    if (ymn <= aoi['ymin']) {
      ymx <- ymx + res[2]
    }
    else {
      ymn <- ymn - res[2]
    }
  }
  aoi[1] <- xmn
  aoi[2] <- ymn
  aoi[3] <- xmx
  aoi[4] <- ymx
  aoi
}

#' Convert AOI
#'
#' Converts an AOI from a variety of possible input types to an `sf` style bbox.
#'
#' @param aoi Numeric; bounding coordinates or an `sf` or `raster` object from
#'   which they can be derived.
#' @return `sf` bbox object with same crs as input.
#' @keywords internal
#' @rdname convert_aoi
#' @importFrom raster extent
#' @importFrom sf st_bbox st_crs st_as_sfc st_intersects
#' @importFrom utils data
#'
convert_aoi <- function(aoi = NULL) {
  UseMethod('convert_aoi')
}

#' @rdname convert_aoi
#' @inherit convert_aoi return
#' @method convert_aoi numeric
#'
convert_aoi.numeric <- function(aoi = NULL) {
    # dumb check for malformed vectors
    if(aoi[3] <= aoi[1]) {
      stop('Please check that AOI coordinates are ordered correctly
           - xmin, ymin, xmax, ymax.')
    }

    aoi <- structure(aoi, names = c("xmin", "ymin", "xmax", "ymax"),
                     class = "bbox", crs = sf::st_crs(4283))
    message("Assuming AOI coordinates are in EPSG:4283 and ordered correctly.")
    aoi
  }

#' @rdname convert_aoi
#' @inherit convert_aoi return
#' @method convert_aoi Raster
#'
convert_aoi.Raster <- function(aoi = NULL) {

    aoi_crs <- sf::st_crs(aoi@crs@projargs)
    aoi <- raster::extent(aoi)
    sf::st_bbox(aoi, crs = aoi_crs)
}

#' @rdname convert_aoi
#' @inherit convert_aoi return
#' @method convert_aoi Extent
#'
convert_aoi.Extent <- function(aoi = NULL) {
    message("Assuming AOI coordinates are in EPSG:4283.")
    sf::st_bbox(aoi, crs = sf::st_crs(4283))
  }

#' @rdname convert_aoi
#' @inherit convert_aoi return
#' @method convert_aoi sf
#'
convert_aoi.sf <- function(aoi = NULL) {
  aoi <- sf::st_as_sfc(sf::st_bbox(aoi), crs = sf::st_crs(aoi))
  sf::st_bbox(aoi)
}

#' @rdname convert_aoi
#' @inherit convert_aoi return
#' @method convert_aoi sfc
#'
convert_aoi.sfc <- function(aoi = NULL) {
  aoi <- sf::st_as_sfc(sf::st_bbox(aoi), crs = sf::st_crs(aoi))
  sf::st_bbox(aoi)
}

#' Validate AOI
#'
#' Checks that an area of interest is of appropriate projection, size, and
#' extent.
#'
#' @param aoi Numeric; bounding coordinates or an `sf` or `raster` object from
#'   which they can be derived.
#' @param product Character, one of the options from column 'Short_Name' in
#'   \code{\link[slga:slga_product_info]{slga_product_info}}.
#' @keywords internal
#' @importFrom raster extent
#' @importFrom sf st_crs st_as_sfc st_intersects
#' @importFrom utils data
#'
validate_aoi <- function(aoi = NULL, product = NULL) {

  ext <- if(!inherits(aoi, 'bbox')) {
    convert_aoi(aoi)
  } else {
    aoi
  }

  # check crs, transform if not in 4283
  ext <- if(is.na(attr(ext, 'crs')$epsg)) {
    crs_bits <- sort(unlist(strsplit(attr(ext, 'crs')$proj4string, ' ')))
    gda94_bits <- sort(unlist(strsplit(
      '+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs', ' ')))
    if(!identical(crs_bits, gda94_bits)) {
      message('Transforming aoi coordinates to EPSG:4283')
      transform_bb(ext, 4283)
    } else {
      ext
    }
    } else if(attr(ext, 'crs')$epsg != 4283) {
    message('Transforming aoi coordinates to EPSG:4283')
    transform_bb(ext, 4283)
  } else {
    ext
  }

  # check extent at least partly covers the requested product
  slga_product_info <- NULL
  utils::data('slga_product_info', envir = environment())
  prd <- slga_product_info[which(slga_product_info$Short_Name == product), ]
  prd <- c(prd[['xmin']], prd[['ymin']], prd[['xmax']], prd[['ymax']])
  prd_aoi <- structure(prd, names = c("xmin", "ymin", "xmax", "ymax"),
              class = "bbox", crs =  sf::st_crs(4283))
  # cast both extents to sfc and check intersect
  # note slightly dodgy as unprojected
  ol <- suppressMessages(
    sf::st_intersects(sf::st_as_sfc(ext), sf::st_as_sfc(prd_aoi))
    )
  if(length(ol[[1]]) == 0L) {
    stop('AOI does not overlap requested product extent.')
  }

  # check extent isn't too big
  x_range <- abs(ext[1] - ext[3])
  y_range <- abs(ext[2] - ext[4])
  if(any(x_range > 3, y_range > 3)) {
    stop('The requested aoi is too large;
         please restrict to a maximum of 3x3 decimal degrees.')
  }

  # Align extent to source to avoid server-side interpolation and grid shift
  align_aoi(aoi = ext, product = product)
  }

#' Validate soils product/attribute combination
#'
#' Check whether the requested soils attribute is available for the requested
#' soils product.
#'
#' @param product Character, one of the options from column 'Code' in
#'   code{\link[slga:slga_product_info]{slga_product_info}}.
#' @param attribute Character, one of the options from column 'Code' in
#'   code{\link[slga:slga_attribute_info]{slga_attribute_info}}.
#' @return Logical; TRUE if available
#' @keywords internal
#'
check_avail <- function(product = NULL, attribute = NULL) {

  slga_attribute_info <- NULL
  utils::data('slga_attribute_info', envir = environment())

  slga_attribute_info[which(slga_attribute_info$Code == attribute), product]

}

