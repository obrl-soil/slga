#' transform a bounding box
#'
#' Transforms an `sf` style bounding box object into the specified coordinate
#' reference system.
#'
#' @param bbox Object of class 'bbox' generated by `sf::st_bbox()`
#' @param crs EPSG code of desired coordinate reference system.
#' @return 'bbox' object with the desired CRS.
#' @note This is a stopgap until and unless a dedicated sf method for bbox
#' transformations is written. Currently used to coerce to WGS84 under specific
#' circumstances. Since this helper was written for an Australia-specific package,
#' it is assumed that it will be used to transform coordinates from a fairly
#' limited list of known crs's, chiefly GDA94 (EPSG:4283) and its associated
#' UTM and Albers equal area projections.
#' @keywords Internal
#' @importFrom sf st_bbox st_crs st_point st_sfc st_transform
#'
transform_bb <- function(bbox = NULL, crs = 4326) {
  ll <- sf::st_point(c(bbox[1], bbox[2]))
  ur <- sf::st_point(c(bbox[3], bbox[4]))
  pts <- sf::st_sfc(ll, ur, crs = sf::st_crs(bbox))
  new <- sf::st_transform(pts, crs)
  sf::st_bbox(new)
}

#' align bounding box
#'
#' Cheerfully stolen from raster package and adapted to sf bbox objects. This is
#' designed to prevent WCS server-side interpolation.
#' @param aoi `sf` bbox object
#' @param product Character, one of the options from column 'Code' in
#'   `slga_product_info`.
#' @snap Character; 'near', 'in', or 'out'. Defaults to 'out'.
#' @keywords Internal
#' @importFrom utils data
#'
align_aoi <- function(aoi = NULL, product = NULL, snap = "out")
{
  snap <- match.arg(snap, c("near", "in", "out"))
  utils::data('slga_product_info', envir = environment())

  res <- abs(
    c(slga_product_info$offset_x[which(slga_product_info$Code == product)],
      slga_product_info$offset_y[which(slga_product_info$Code == product)]))

  orig <- c(slga_product_info$origin_x[which(slga_product_info$Code == product)],
            slga_product_info$origin_y[which(slga_product_info$Code == product)])

   if (snap == "near") {
    xmn <- round((aoi['xmin'] - orig[1])/res[1]) * res[1] +
      orig[1]
    xmx <- round((aoi['xmax'] - orig[1])/res[1]) * res[1] +
      orig[1]
    ymn <- round((aoi['ymin'] - orig[2])/res[2]) * res[2] +
      orig[2]
    ymx <- round((aoi['ymax'] - orig[2])/res[2]) * res[2] +
      orig[2]
  }
  if (snap == "out") {
    xmn <- floor((aoi['xmin'] - orig[1])/res[1]) * res[1] +
      orig[1]
    xmx <- ceiling((aoi['xmax'] - orig[1])/res[1]) * res[1] +
      orig[1]
    ymn <- floor((aoi['ymin'] - orig[2])/res[2]) * res[2] +
      orig[2]
    ymx <- ceiling((aoi['ymax'] - orig[2])/res[2]) * res[2] +
      orig[2]
  }
  if (snap == "in") {
    xmn <- ceiling((aoi['xmin'] - orig[1])/res[1]) * res[1] +
      orig[1]
    xmx <- floor((aoi['xmax'] - orig[1])/res[1]) * res[1] +
      orig[1]
    ymn <- ceiling((aoi['ymin'] - orig[2])/res[2]) * res[2] +
      orig[2]
    ymx <- floor((aoi['ymax'] - orig[2])/res[2]) * res[2] +
      orig[2]
  }
  if (xmn == xmx) {
    if (xmn <= aoi['xmin']) {
      xmx <- xmx + res[1]
    }
    else {
      xmn <- xmn - res[1]
    }
  }
  if (ymn == ymx) {
    if (ymn <= aoi['ymin']) {
      ymx <- ymx + res[2]
    }
    else {
      ymn <- ymn - res[2]
    }
  }
  aoi[1] <- xmn
  aoi[2] <- ymn
  aoi[3] <- xmx
  aoi[4] <- ymx
  aoi
}

#' Validate AOI
#'
#' Checks that an area of interest is of appropriate projection, size, and extent.
#'
#' @param aoi length 4 numeric vector, `raster` object, or `sf` object.
#' @param product Character, one of the options from column 'Code' in
#'   `slga_product_info`.
#' @keywords Internal
#' @importFrom raster extent
#' @importFrom sf st_crs st_as_sfc st_intersects
#' @importFrom utils data
#'
validate_aoi <- function(aoi = NULL, product = NULL) {

  # 1. for simple bounding vector, convert to sf style bbox
  if(all(length(aoi) == 4, inherits(aoi, 'numeric'))) {
    aoi <- structure(aoi, names = c("xmin", "ymin", "xmax", "ymax"),
                     class = "bbox", crs = '+init=EPSG:4326')
    message("Assuming AOI coordinates are in EPSG:4326 and ordered correctly.")
  }

  # 2. Do the same for rasters
  if(inherits(aoi, 'Raster')) {
    aoi_crs <- sf::st_crs(aoi@crs@projargs)
    aoi <- raster::extent(aoi)
    # low-dependency conversion to sf-style bbox pinched from sf/bbox.r
    aoi <- c(attr(aoi, 'xmin'), attr(aoi, 'ymin'),
           attr(aoi, 'xmax'), attr(aoi, 'ymax'))
    aoi <- structure(aoi, names = c("xmin", "ymin", "xmax", "ymax"),
                     class = "bbox", crs = aoi_crs)
  }
  # note that EPSG code may be lost for some projections eg EPSG:3577

  # 3. Now assuming sf object here
  # check crs, convert if not 4326
  ext <- if(inherits(aoi, 'sf')) {
    sf::st_bbox(aoi)
  } else {
    aoi
  }
  ext <- if(is.na(attr(ext, 'crs')$epsg)) {
    if(grepl('+proj=lonlat|+datum=WGS84',
             attr(ext, 'crs')$proj4string) == FALSE) {
      message('Transforming AOI coordinates to EPSG:4326')
      transform_bb(ext, 4326)
    } else {
      ext
    }
    } else if(attr(ext, 'crs')$epsg != 4326) {
    message('Transforming aoi coordinates to EPSG:4326')
    transform_bb(ext, 4326)
  } else {
    ext
  }

  # check extent at least partly covers the requested data
  # NOTE dependent on product requested so
  utils::data('slga_product_info', envir = environment())
  prd <- slga_product_info[which(slga_product_info$Code == product), ]
  prd <-
    structure(c(prd[['xmin']], prd[['ymin']], prd[['xmax']], prd[['ymax']]),
              names = c("xmin", "ymin", "xmax", "ymax"),
              class = "bbox", crs = '+init=EPSG:4326')

  # cast both extents to sfc and check intersect
  # note slightly dodgy as unprojected
  ol <- suppressMessages(
    sf::st_intersects(sf::st_as_sfc(ext), sf::st_as_sfc(prd))
    )
  if(length(ol[[1]]) == 0L) {
    stop('AOI does not overlap requested product extent.')
  }

  # check extent isn't too big
  x_range <- abs(ext[1] - ext[3])
  y_range <- abs(ext[2] - ext[4])
  if(any(x_range > 3, y_range > 3)) {
    stop('The requested aoi is too large;
         please to restrict to a maximum of 3x3 decimal degrees.')
  }

  # Align extent to source to avoid server-side interpolation and grid shift
  align_aoi(aoi = ext, product = product, snap = "out")
  }



