#' transform a bounding box
#'
#' Transforms an `sf` style bounding box object into the specified coordinate
#' reference system.
#'
#' @param bbox Object of class 'bbox' generated by
#'   \code{\link[sf:st_bbox]{sf::st_bbox}}.
#' @param crs EPSG code of desired coordinate reference system.
#' @return 'bbox' object with the desired CRS, large enough to ensure returned
#' dataset covers entire input object.
#' @note This is a stopgap until and unless a dedicated sf method for bbox
#' transformations is written. Currently used to coerce to WGS84 under specific
#' circumstances. Since this helper was written for an Australia-specific package,
#' it is assumed that it will be used to transform coordinates from a fairly
#' limited list of known crs's, chiefly GDA94 (EPSG:4283) and its associated
#' UTM and Albers equal area projections.
#' @keywords internal
#' @importFrom sf st_bbox st_crs st_point st_sfc st_transform
#'
transform_bb <- function(bbox = NULL, crs = 4283) {
  box <- sf::st_as_sfc(bbox, crs = sf::st_crs(bbox))
  new <- sf::st_transform(box, crs)
  sf::st_bbox(new)
}

#' align bounding box
#'
#' Cheerfully stolen from code{\link[raster:alignExtent]{raster::alignExtent}}
#' and adapted to sf bbox objects. This is designed to prevent WCS server-side
#' interpolation.
#'
#' @param aoi `sf` bbox object
#' @param product Character, one of the options from column 'Short_Name' in
#'   \code{\link[slga:slga_product_info]{slga_product_info}}.
#' @param snap Character; 'near', 'in', or 'out'. Defaults to 'out'.
#' @keywords internal
#' @importFrom utils data
#'
align_aoi <- function(aoi = NULL, product = NULL, snap = "out") {
  snap <- match.arg(snap, c("near", "in", "out"))
  slga_product_info <- NULL
  utils::data('slga_product_info', envir = environment())

  res <- abs(
    c(slga_product_info$offset_x[which(slga_product_info$Short_Name == product)],
      slga_product_info$offset_y[which(slga_product_info$Short_Name == product)]))

  orig <-
    c(slga_product_info$origin_x[which(slga_product_info$Short_Name == product)],
      slga_product_info$origin_y[which(slga_product_info$Short_Name == product)])

   if (snap == "near") {
    xmn <- round((aoi['xmin'] - orig[1])/res[1]) * res[1] + orig[1]
    xmx <- round((aoi['xmax'] - orig[1])/res[1]) * res[1] + orig[1]
    ymn <- round((aoi['ymin'] - orig[2])/res[2]) * res[2] + orig[2]
    ymx <- round((aoi['ymax'] - orig[2])/res[2]) * res[2] + orig[2]
  }
  if (snap == "out") {
    xmn <- floor((aoi['xmin']   - orig[1])/res[1]) * res[1] + orig[1]
    xmx <- ceiling((aoi['xmax'] - orig[1])/res[1]) * res[1] + orig[1]
    ymn <- floor((aoi['ymin']   - orig[2])/res[2]) * res[2] + orig[2]
    ymx <- ceiling((aoi['ymax'] - orig[2])/res[2]) * res[2] + orig[2]
  }
  if (snap == "in") {
    xmn <- ceiling((aoi['xmin'] - orig[1])/res[1]) * res[1] + orig[1]
    xmx <- floor((aoi['xmax']   - orig[1])/res[1]) * res[1] + orig[1]
    ymn <- ceiling((aoi['ymin'] - orig[2])/res[2]) * res[2] + orig[2]
    ymx <- floor((aoi['ymax']   - orig[2])/res[2]) * res[2] + orig[2]
  }
  if (xmn == xmx) {
    if (xmn <= aoi['xmin']) {
      xmx <- xmx + res[1]
    }
    else {
      xmn <- xmn - res[1]
    }
  }
  if (ymn == ymx) {
    if (ymn <= aoi['ymin']) {
      ymx <- ymx + res[2]
    }
    else {
      ymn <- ymn - res[2]
    }
  }
  aoi[1] <- xmn
  aoi[2] <- ymn
  aoi[3] <- xmx
  aoi[4] <- ymx
  aoi
}

#' Convert AOI
#'
#' Converts an AOI from a variety of possible input types to an `sf` style bbox.
#'
#' @param aoi Numeric; bounding coordinates or an `sf` or `raster` object from
#'   which they can be derived.
#' @return `sf` bbox object with same crs as input.
#' @keywords internal
#' @rdname convert_aoi
#' @importFrom raster extent
#' @importFrom sf st_bbox st_crs st_as_sfc st_intersects
#' @importFrom utils data
#'
convert_aoi <- function(aoi = NULL) {
  UseMethod('convert_aoi')
}

#' @rdname convert_aoi
#' @inherit convert_aoi return
#' @method convert_aoi numeric
#'
convert_aoi.numeric <- function(aoi = NULL) {
    # dumb check for malformed vectors
    if(aoi[3] <= aoi[1]) {
      stop('Please check that AOI coordinates are ordered correctly
           - xmin, ymin, xmax, ymax.')
    }
    message("Assuming AOI coordinates are in EPSG:4283 and ordered correctly.")
    structure(aoi, names = c("xmin", "ymin", "xmax", "ymax"),
              class = "bbox", crs = sf::st_crs(4283))
  }

#' @rdname convert_aoi
#' @inherit convert_aoi return
#' @method convert_aoi Raster
#'
convert_aoi.Raster <- function(aoi = NULL) {
    aoi_crs <- sf::st_crs(aoi@crs@projargs)
    aoi <- raster::extent(aoi)
    sf::st_bbox(aoi, crs = aoi_crs)
}

#' @rdname convert_aoi
#' @inherit convert_aoi return
#' @method convert_aoi Extent
#'
convert_aoi.Extent <- function(aoi = NULL) {
    message("Assuming AOI coordinates are in EPSG:4283.")
    sf::st_bbox(aoi, crs = sf::st_crs(4283))
  }

#' @rdname convert_aoi
#' @inherit convert_aoi return
#' @method convert_aoi sf
#'
convert_aoi.sf <- function(aoi = NULL) {
  aoi <- sf::st_as_sfc(sf::st_bbox(aoi), crs = sf::st_crs(aoi))
  sf::st_bbox(aoi)
}

#' @rdname convert_aoi
#' @inherit convert_aoi return
#' @method convert_aoi sfc
#'
convert_aoi.sfc <- function(aoi = NULL) {
  aoi <- sf::st_as_sfc(sf::st_bbox(aoi), crs = sf::st_crs(aoi))
  sf::st_bbox(aoi)
}

#' Tile AOI
#'
#' If an AOI is Large, chop it up so that a series of GETs can be sent
#'
#' @param aoi sf bbox already converted from user input and aligned to requrested
#' product
#' @param size Number, max side length of tiles in decimal degrees. Default 1.
#' @return a list of bounding boxes subdividing the area of interest. Return
#' list is not yet aligned to product (handled later).
#'
#' @keywords internal
#' @importFrom sf st_crs
tile_aoi <- function(aoi = NULL, size = 1) {
  # at this point, aoi has been turned into an sf bbox and tweaked to align with
  # requested product. NB can do this with sf funs in 4 lines but its slower
  xrng <- sort(unique(c(aoi[1], seq(aoi[1], aoi[3], by = size), aoi[3])))
  yrng <- sort(unique(c(aoi[2], seq(aoi[2], aoi[4], by = size), aoi[4])))
  # list of bboxes (unvalidated!!!)
  mapply(function(llxi, llyi, urxi, uryi) {
    structure(c(xrng[llxi], yrng[llyi], xrng[urxi], yrng[uryi]),
              names = c("xmin", "ymin", "xmax", "ymax"),
              class = "bbox", crs = sf::st_crs(4283))
  },
  llxi = rep(seq(length(xrng) - 1), times = length(yrng) - 1),
  llyi = rep(seq(length(yrng) - 1), each = length(xrng) - 1),
  urxi = rep(2:length(xrng), times = length(yrng) - 1),
  uryi = rep(2:length(yrng), each = length(xrng) - 1),
  SIMPLIFY = FALSE)
}

#' Validate AOI
#'
#' Checks that an area of interest is of appropriate projection, size, and
#' extent.
#'
#' @param aoi Numeric; bounding coordinates or an `sf` or `raster` object from
#'   which they can be derived.
#' @param product Character, one of the options from column 'Short_Name' in
#'   \code{\link[slga:slga_product_info]{slga_product_info}}.
#' @return sf style bbox or list of same, aligned to requested product.
#' @keywords internal
#' @importFrom raster extent
#' @importFrom sf st_crs st_as_sfc st_intersects
#' @importFrom utils data
#'
validate_aoi <- function(aoi = NULL, product = NULL) {

  ext <- if(!inherits(aoi, 'bbox')) {
    convert_aoi(aoi)
  } else {
    aoi
  }

  # check crs, transform if not in 4283
  ext <- if(is.na(attr(ext, 'crs')$epsg)) {
    crs_bits <- sort(unlist(strsplit(attr(ext, 'crs')$proj4string, ' ')))
    gda94_bits <- sort(unlist(strsplit(
      '+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs', ' ')))
    if(!identical(crs_bits, gda94_bits)) {
      message('Transforming aoi coordinates to EPSG:4283')
      transform_bb(ext, 4283)
    } else {
      ext
    }
    } else if(attr(ext, 'crs')$epsg != 4283) {
    message('Transforming aoi coordinates to EPSG:4283')
    transform_bb(ext, 4283)
  } else {
    ext
  }

  # check extent at least partly covers the requested product
  slga_product_info <- NULL
  utils::data('slga_product_info', envir = environment())
  prd <- slga_product_info[which(slga_product_info$Short_Name == product), ]
  prd <- c(prd[['xmin']], prd[['ymin']], prd[['xmax']], prd[['ymax']])
  prd_aoi <- structure(prd, names = c("xmin", "ymin", "xmax", "ymax"),
              class = "bbox", crs =  sf::st_crs(4283))
  # cast both extents to sfc and check intersect
  # note slightly dodgy as unprojected
  ol <- suppressMessages(
    sf::st_intersects(sf::st_as_sfc(ext), sf::st_as_sfc(prd_aoi))
    )
  if(length(ol[[1]]) == 0L) {
    stop('AOI does not overlap requested product extent.')
  }

  # Align extent to source to avoid server-side interpolation and grid shift
  ext <- align_aoi(aoi = ext, product = product)

  # check extent isn't too big. If it is, tile
  x_range <- abs(ext[1] - ext[3])
  y_range <- abs(ext[2] - ext[4])
  # 0.001 below prevents unneccessary tiling due to aoi snap
  if(any(x_range > 1.001, y_range > 1.001)) {
   # returns a list of (max size) 1x1' ish bboxes
   exts <- lapply(tile_aoi(ext), function(x) { align_aoi(x, product) })
   # chuck out any tiles that don't overlap the requested product
   keep <- sapply(exts, function(x) {
     ol <- suppressMessages(
         sf::st_intersects(sf::st_as_sfc(x), sf::st_as_sfc(prd_aoi))
       )
     if(length(ol[[1]]) == 0L) { FALSE } else { TRUE }
   })
   exts <- exts[keep]
   if(length(exts) == 1) { exts[[1]] } else { exts }
  } else {
    # returns a bbox
    ext
  }
}

#' Validate soils product/attribute combination
#'
#' Check whether the requested soils attribute is available for the requested
#' soils product.
#'
#' @param product Character, one of the options from column 'Code' in
#'   code{\link[slga:slga_product_info]{slga_product_info}} where Type = 'Soil'.
#' @param attribute Character, one of the options from column 'Code' in
#'   code{\link[slga:slga_attribute_info]{slga_attribute_info}}.
#' @return Logical; TRUE if available
#' @examples
#' check_avail('NAT', 'CFG')
#' check_avail('SA',  'CFG')
#' @importFrom utils data
#' @export
#'
check_avail <- function(product = NULL, attribute = NULL) {
  slga_attribute_info <- NULL
  utils::data('slga_attribute_info', envir = environment())
  slga_attribute_info[which(slga_attribute_info$Code == attribute), product]
}
